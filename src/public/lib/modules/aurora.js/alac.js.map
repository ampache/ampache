{
  "version": 3,
  "file": "generated.js",
  "sources": [
    "/Users/devongovett/projects/codecs/alac.js/node_modules/browserify/node_modules/browser-pack/_prelude.js",
    "/Users/devongovett/projects/codecs/alac.js/src/ag_dec.js",
    "/Users/devongovett/projects/codecs/alac.js/src/decoder.js",
    "/Users/devongovett/projects/codecs/alac.js/src/dp_dec.js",
    "/Users/devongovett/projects/codecs/alac.js/src/matrix_dec.js"
  ],
  "names": [],
  "mappings": "AAAA;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA",
  "sourcesContent": [
    "(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);throw new Error(\"Cannot find module '\"+o+\"'\")}var f=n[o]={exports:{}};t[o][0].call(f.exports,function(e){var n=t[o][1][e];return s(n?n:e)},f,f.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})",
    "// Generated by CoffeeScript 1.7.1\n(function() {\n  var Aglib;\n\n  Aglib = (function() {\n    var BITOFF, KB0, MAX_DATATYPE_BITS_16, MAX_PREFIX_16, MAX_PREFIX_32, MAX_RUN_DEFAULT, MB0, MDENSHIFT, MMULSHIFT, MOFF, N_MAX_MEAN_CLAMP, N_MEAN_CLAMP_VAL, PB0, QB, QBSHIFT, dyn_get_16, dyn_get_32, lead;\n\n    function Aglib() {}\n\n    PB0 = 40;\n\n    MB0 = 10;\n\n    KB0 = 14;\n\n    MAX_RUN_DEFAULT = 255;\n\n    MAX_PREFIX_16 = 9;\n\n    MAX_PREFIX_32 = 9;\n\n    QBSHIFT = 9;\n\n    QB = 1 << QBSHIFT;\n\n    MMULSHIFT = 2;\n\n    MDENSHIFT = QBSHIFT - MMULSHIFT - 1;\n\n    MOFF = 1 << (MDENSHIFT - 2);\n\n    N_MAX_MEAN_CLAMP = 0xFFFF;\n\n    N_MEAN_CLAMP_VAL = 0xFFFF;\n\n    MMULSHIFT = 2;\n\n    BITOFF = 24;\n\n    MAX_DATATYPE_BITS_16 = 16;\n\n    lead = function(input) {\n      var curbyte, output;\n      output = 0;\n      curbyte = 0;\n      while (true) {\n        curbyte = input >>> 24;\n        if (curbyte) {\n          break;\n        }\n        output += 8;\n        curbyte = input >>> 16;\n        if (curbyte & 0xff) {\n          break;\n        }\n        output += 8;\n        curbyte = input >>> 8;\n        if (curbyte & 0xff) {\n          break;\n        }\n        output += 8;\n        curbyte = input;\n        if (curbyte & 0xff) {\n          break;\n        }\n        output += 8;\n        return output;\n      }\n      if (curbyte & 0xf0) {\n        curbyte >>>= 4;\n      } else {\n        output += 4;\n      }\n      if (curbyte & 0x8) {\n        return output;\n      }\n      if (curbyte & 0x4) {\n        return output + 1;\n      }\n      if (curbyte & 0x2) {\n        return output + 2;\n      }\n      if (curbyte & 0x1) {\n        return output + 3;\n      }\n      return output + 4;\n    };\n\n    dyn_get_16 = function(data, m, k) {\n      var bitsInPrefix, offs, result, stream, v;\n      offs = data.bitPosition;\n      stream = data.peek(32 - offs) << offs;\n      bitsInPrefix = lead(~stream);\n      if (bitsInPrefix >= MAX_PREFIX_16) {\n        data.advance(MAX_PREFIX_16 + MAX_DATATYPE_BITS_16);\n        stream <<= MAX_PREFIX_16;\n        result = stream >>> (32 - MAX_DATATYPE_BITS_16);\n      } else {\n        data.advance(bitsInPrefix + k);\n        stream <<= bitsInPrefix + 1;\n        v = stream >>> (32 - k);\n        result = bitsInPrefix * m + v - 1;\n        if (v < 2) {\n          result -= v - 1;\n        } else {\n          data.advance(1);\n        }\n      }\n      return result;\n    };\n\n    dyn_get_32 = function(data, m, k, maxbits) {\n      var offs, result, stream, v;\n      offs = data.bitPosition;\n      stream = data.peek(32 - offs) << offs;\n      result = lead(~stream);\n      if (result >= MAX_PREFIX_32) {\n        data.advance(MAX_PREFIX_32);\n        return data.read(maxbits);\n      } else {\n        data.advance(result + 1);\n        if (k !== 1) {\n          stream <<= result + 1;\n          result *= m;\n          v = stream >>> (32 - k);\n          data.advance(k - 1);\n          if (v > 1) {\n            result += v - 1;\n            data.advance(1);\n          }\n        }\n      }\n      return result;\n    };\n\n    Aglib.ag_params = function(m, p, k, f, s, maxrun) {\n      return {\n        mb: m,\n        mb0: m,\n        pb: p,\n        kb: k,\n        wb: (1 << k) - 1,\n        qb: QB - p,\n        fw: f,\n        sw: s,\n        maxrun: maxrun\n      };\n    };\n\n    Aglib.dyn_decomp = function(params, data, pc, samples, maxSize) {\n      var c, j, k, kb, m, mb, multiplier, mz, n, ndecode, pb, wb, zmode, _i;\n      pb = params.pb, kb = params.kb, wb = params.wb, mb = params.mb0;\n      zmode = 0;\n      c = 0;\n      while (c < samples) {\n        m = mb >>> QBSHIFT;\n        k = Math.min(31 - lead(m + 3), kb);\n        m = (1 << k) - 1;\n        n = dyn_get_32(data, m, k, maxSize);\n        ndecode = n + zmode;\n        multiplier = -(ndecode & 1) | 1;\n        pc[c++] = ((ndecode + 1) >>> 1) * multiplier;\n        mb = pb * (n + zmode) + mb - ((pb * mb) >> QBSHIFT);\n        if (n > N_MAX_MEAN_CLAMP) {\n          mb = N_MEAN_CLAMP_VAL;\n        }\n        zmode = 0;\n        if (((mb << MMULSHIFT) < QB) && (c < samples)) {\n          zmode = 1;\n          k = lead(mb) - BITOFF + ((mb + MOFF) >> MDENSHIFT);\n          mz = ((1 << k) - 1) & wb;\n          n = dyn_get_16(data, mz, k);\n          if (!(c + n <= samples)) {\n            return false;\n          }\n          for (j = _i = 0; _i < n; j = _i += 1) {\n            pc[c++] = 0;\n          }\n          if (n >= 65535) {\n            zmode = 0;\n          }\n          mb = 0;\n        }\n      }\n      return true;\n    };\n\n    return Aglib;\n\n  })();\n\n  module.exports = Aglib;\n\n}).call(this);\n",
    "// Generated by CoffeeScript 1.7.1\n(function() {\n  var ALACDecoder, AV, Aglib, Dplib, Matrixlib,\n    __hasProp = {}.hasOwnProperty,\n    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };\n\n  AV = (window.AV);\n\n  Aglib = require('./ag_dec');\n\n  Dplib = require('./dp_dec');\n\n  Matrixlib = require('./matrix_dec');\n\n  ALACDecoder = (function(_super) {\n    var ID_CCE, ID_CPE, ID_DSE, ID_END, ID_FIL, ID_LFE, ID_PCE, ID_SCE;\n\n    __extends(ALACDecoder, _super);\n\n    function ALACDecoder() {\n      return ALACDecoder.__super__.constructor.apply(this, arguments);\n    }\n\n    AV.Decoder.register('alac', ALACDecoder);\n\n    ID_SCE = 0;\n\n    ID_CPE = 1;\n\n    ID_CCE = 2;\n\n    ID_LFE = 3;\n\n    ID_DSE = 4;\n\n    ID_PCE = 5;\n\n    ID_FIL = 6;\n\n    ID_END = 7;\n\n    ALACDecoder.prototype.setCookie = function(cookie) {\n      var data, predictorBuffer, _base;\n      data = AV.Stream.fromBuffer(cookie);\n      if (data.peekString(4, 4) === 'frma') {\n        data.advance(12);\n      }\n      if (data.peekString(4, 4) === 'alac') {\n        data.advance(12);\n      }\n      this.config = {\n        frameLength: data.readUInt32(),\n        compatibleVersion: data.readUInt8(),\n        bitDepth: data.readUInt8(),\n        pb: data.readUInt8(),\n        mb: data.readUInt8(),\n        kb: data.readUInt8(),\n        numChannels: data.readUInt8(),\n        maxRun: data.readUInt16(),\n        maxFrameBytes: data.readUInt32(),\n        avgBitRate: data.readUInt32(),\n        sampleRate: data.readUInt32()\n      };\n      (_base = this.format).bitsPerChannel || (_base.bitsPerChannel = this.config.bitDepth);\n      this.mixBuffers = [new Int32Array(this.config.frameLength), new Int32Array(this.config.frameLength)];\n      predictorBuffer = new ArrayBuffer(this.config.frameLength * 4);\n      this.predictor = new Int32Array(predictorBuffer);\n      return this.shiftBuffer = new Int16Array(predictorBuffer);\n    };\n\n    ALACDecoder.prototype.readChunk = function(data) {\n      var buf, bytesShifted, ch, chanBits, channelIndex, channels, coefs, count, dataByteAlignFlag, denShift, elementInstanceTag, end, escapeFlag, i, j, kb, maxRun, mb, mixBits, mixRes, mode, num, numChannels, out16, output, params, partialFrame, pb, pbFactor, samples, shift, shiftbits, status, table, tag, unused, val, _i, _j, _k, _l, _m, _n, _o, _ref, _ref1, _ref2;\n      if (!this.stream.available(4)) {\n        return;\n      }\n      data = this.bitstream;\n      samples = this.config.frameLength;\n      numChannels = this.config.numChannels;\n      channelIndex = 0;\n      output = new ArrayBuffer(samples * numChannels * this.config.bitDepth / 8);\n      end = false;\n      while (!end) {\n        tag = data.read(3);\n        switch (tag) {\n          case ID_SCE:\n          case ID_LFE:\n          case ID_CPE:\n            channels = tag === ID_CPE ? 2 : 1;\n            if (channelIndex + channels > numChannels) {\n              throw new Error('Too many channels!');\n            }\n            elementInstanceTag = data.read(4);\n            unused = data.read(12);\n            if (unused !== 0) {\n              throw new Error('Unused part of header does not contain 0, it should');\n            }\n            partialFrame = data.read(1);\n            bytesShifted = data.read(2);\n            escapeFlag = data.read(1);\n            if (bytesShifted === 3) {\n              throw new Error(\"Bytes are shifted by 3, they shouldn't be\");\n            }\n            if (partialFrame) {\n              samples = data.read(32);\n            }\n            if (escapeFlag === 0) {\n              shift = bytesShifted * 8;\n              chanBits = this.config.bitDepth - shift + channels - 1;\n              mixBits = data.read(8);\n              mixRes = data.read(8);\n              mode = [];\n              denShift = [];\n              pbFactor = [];\n              num = [];\n              coefs = [];\n              for (ch = _i = 0; _i < channels; ch = _i += 1) {\n                mode[ch] = data.read(4);\n                denShift[ch] = data.read(4);\n                pbFactor[ch] = data.read(3);\n                num[ch] = data.read(5);\n                table = coefs[ch] = new Int16Array(32);\n                for (i = _j = 0, _ref = num[ch]; _j < _ref; i = _j += 1) {\n                  table[i] = data.read(16);\n                }\n              }\n              if (bytesShifted) {\n                shiftbits = data.copy();\n                data.advance(shift * channels * samples);\n              }\n              _ref1 = this.config, mb = _ref1.mb, pb = _ref1.pb, kb = _ref1.kb, maxRun = _ref1.maxRun;\n              for (ch = _k = 0; _k < channels; ch = _k += 1) {\n                params = Aglib.ag_params(mb, (pb * pbFactor[ch]) / 4, kb, samples, samples, maxRun);\n                status = Aglib.dyn_decomp(params, data, this.predictor, samples, chanBits);\n                if (!status) {\n                  throw new Error('Error in Aglib.dyn_decomp');\n                }\n                if (mode[ch] === 0) {\n                  Dplib.unpc_block(this.predictor, this.mixBuffers[ch], samples, coefs[ch], num[ch], chanBits, denShift[ch]);\n                } else {\n                  Dplib.unpc_block(this.predictor, this.predictor, samples, null, 31, chanBits, 0);\n                  Dplib.unpc_block(this.predictor, this.mixBuffers[ch], samples, coefs[ch], num[ch], chanBits, denShift[ch]);\n                }\n              }\n            } else {\n              chanBits = this.config.bitDepth;\n              shift = 32 - chanBits;\n              for (i = _l = 0; _l < samples; i = _l += 1) {\n                for (ch = _m = 0; _m < channels; ch = _m += 1) {\n                  val = (data.read(chanBits) << shift) >> shift;\n                  this.mixBuffers[ch][i] = val;\n                }\n              }\n              mixBits = mixRes = 0;\n              bytesShifted = 0;\n            }\n            if (bytesShifted) {\n              shift = bytesShifted * 8;\n              for (i = _n = 0, _ref2 = samples * channels; _n < _ref2; i = _n += 1) {\n                this.shiftBuffer[i] = shiftbits.read(shift);\n              }\n            }\n            switch (this.config.bitDepth) {\n              case 16:\n                out16 = new Int16Array(output, channelIndex);\n                if (channels === 2) {\n                  Matrixlib.unmix16(this.mixBuffers[0], this.mixBuffers[1], out16, numChannels, samples, mixBits, mixRes);\n                } else {\n                  j = 0;\n                  buf = this.mixBuffers[0];\n                  for (i = _o = 0; _o < samples; i = _o += 1) {\n                    out16[j] = buf[i];\n                    j += numChannels;\n                  }\n                }\n                break;\n              default:\n                throw new Error('Only supports 16-bit samples right now');\n            }\n            channelIndex += channels;\n            break;\n          case ID_CCE:\n          case ID_PCE:\n            throw new Error(\"Unsupported element: \" + tag);\n            break;\n          case ID_DSE:\n            elementInstanceTag = data.read(4);\n            dataByteAlignFlag = data.read(1);\n            count = data.read(8);\n            if (count === 255) {\n              count += data.read(8);\n            }\n            if (dataByteAlignFlag) {\n              data.align();\n            }\n            data.advance(count * 8);\n            if (!(data.pos < data.length)) {\n              throw new Error('buffer overrun');\n            }\n            break;\n          case ID_FIL:\n            count = data.read(4);\n            if (count === 15) {\n              count += data.read(8) - 1;\n            }\n            data.advance(count * 8);\n            if (!(data.pos < data.length)) {\n              throw new Error('buffer overrun');\n            }\n            break;\n          case ID_END:\n            data.align();\n            end = true;\n            break;\n          default:\n            throw new Error(\"Unknown element: \" + tag);\n        }\n        if (channelIndex > numChannels) {\n          throw new Error('Channel index too large.');\n        }\n      }\n      return new Int16Array(output);\n    };\n\n    return ALACDecoder;\n\n  })(AV.Decoder);\n\n  module.exports = ALACDecoder;\n\n}).call(this);\n",
    "// Generated by CoffeeScript 1.7.1\n(function() {\n  var Dplib;\n\n  Dplib = (function() {\n    var copy;\n\n    function Dplib() {}\n\n    copy = function(dst, dstOffset, src, srcOffset, n) {\n      var destination, source;\n      destination = new Uint8Array(dst, dstOffset, n);\n      source = new Uint8Array(src, srcOffset, n);\n      destination.set(source);\n      return dst;\n    };\n\n    Dplib.unpc_block = function(pc1, out, num, coefs, active, chanbits, denshift) {\n      var a0, a1, a2, a3, a4, a5, a6, a7, b0, b1, b2, b3, b4, b5, b6, b7, chanshift, dd, del, del0, denhalf, i, j, lim, offset, prev, sg, sgn, sum1, top, _i, _j, _k, _l, _m, _n, _o, _p, _ref, _ref1;\n      chanshift = 32 - chanbits;\n      denhalf = 1 << (denshift - 1);\n      out[0] = pc1[0];\n      if (active === 0) {\n        return copy(out, 0, pc1, 0, num * 4);\n      }\n      if (active === 31) {\n        prev = out[0];\n        for (i = _i = 1; _i < num; i = _i += 1) {\n          del = pc1[i] + prev;\n          prev = (del << chanshift) >> chanshift;\n          out[i] = prev;\n        }\n        return;\n      }\n      for (i = _j = 1; _j <= active; i = _j += 1) {\n        del = pc1[i] + out[i - 1];\n        out[i] = (del << chanshift) >> chanshift;\n      }\n      lim = active + 1;\n      if (active === 4) {\n        a0 = coefs[0], a1 = coefs[1], a2 = coefs[2], a3 = coefs[3];\n        for (j = _k = lim; _k < num; j = _k += 1) {\n          top = out[j - lim];\n          offset = j - 1;\n          b0 = top - out[offset];\n          b1 = top - out[offset - 1];\n          b2 = top - out[offset - 2];\n          b3 = top - out[offset - 3];\n          sum1 = (denhalf - a0 * b0 - a1 * b1 - a2 * b2 - a3 * b3) >> denshift;\n          del = del0 = pc1[j];\n          sg = (-del >>> 31) | (del >> 31);\n          del += top + sum1;\n          out[j] = (del << chanshift) >> chanshift;\n          if (sg > 0) {\n            sgn = (-b3 >>> 31) | (b3 >> 31);\n            a3 -= sgn;\n            del0 -= 1 * ((sgn * b3) >> denshift);\n            if (del0 <= 0) {\n              continue;\n            }\n            sgn = (-b2 >>> 31) | (b2 >> 31);\n            a2 -= sgn;\n            del0 -= 2 * ((sgn * b2) >> denshift);\n            if (del0 <= 0) {\n              continue;\n            }\n            sgn = (-b1 >>> 31) | (b1 >> 31);\n            a1 -= sgn;\n            del0 -= 3 * ((sgn * b1) >> denshift);\n            if (del0 <= 0) {\n              continue;\n            }\n            a0 -= (-b0 >>> 31) | (b0 >> 31);\n          } else if (sg < 0) {\n            sgn = -((-b3 >>> 31) | (b3 >> 31));\n            a3 -= sgn;\n            del0 -= 1 * ((sgn * b3) >> denshift);\n            if (del0 >= 0) {\n              continue;\n            }\n            sgn = -((-b2 >>> 31) | (b2 >> 31));\n            a2 -= sgn;\n            del0 -= 2 * ((sgn * b2) >> denshift);\n            if (del0 >= 0) {\n              continue;\n            }\n            sgn = -((-b1 >>> 31) | (b1 >> 31));\n            a1 -= sgn;\n            del0 -= 3 * ((sgn * b1) >> denshift);\n            if (del0 >= 0) {\n              continue;\n            }\n            a0 += (-b0 >>> 31) | (b0 >> 31);\n          }\n        }\n        coefs[0] = a0;\n        coefs[1] = a1;\n        coefs[2] = a2;\n        coefs[3] = a3;\n      } else if (active === 8) {\n        a0 = coefs[0], a1 = coefs[1], a2 = coefs[2], a3 = coefs[3], a4 = coefs[4], a5 = coefs[5], a6 = coefs[6], a7 = coefs[7];\n        for (j = _l = lim; _l < num; j = _l += 1) {\n          top = out[j - lim];\n          offset = j - 1;\n          b0 = top - out[offset];\n          b1 = top - out[offset - 1];\n          b2 = top - out[offset - 2];\n          b3 = top - out[offset - 3];\n          b4 = top - out[offset - 4];\n          b5 = top - out[offset - 5];\n          b6 = top - out[offset - 6];\n          b7 = top - out[offset - 7];\n          sum1 = (denhalf - a0 * b0 - a1 * b1 - a2 * b2 - a3 * b3 - a4 * b4 - a5 * b5 - a6 * b6 - a7 * b7) >> denshift;\n          del = del0 = pc1[j];\n          sg = (-del >>> 31) | (del >> 31);\n          del += top + sum1;\n          out[j] = (del << chanshift) >> chanshift;\n          if (sg > 0) {\n            sgn = (-b7 >>> 31) | (b7 >> 31);\n            a7 -= sgn;\n            del0 -= 1 * ((sgn * b7) >> denshift);\n            if (del0 <= 0) {\n              continue;\n            }\n            sgn = (-b6 >>> 31) | (b6 >> 31);\n            a6 -= sgn;\n            del0 -= 2 * ((sgn * b6) >> denshift);\n            if (del0 <= 0) {\n              continue;\n            }\n            sgn = (-b5 >>> 31) | (b5 >> 31);\n            a5 -= sgn;\n            del0 -= 3 * ((sgn * b5) >> denshift);\n            if (del0 <= 0) {\n              continue;\n            }\n            sgn = (-b4 >>> 31) | (b4 >> 31);\n            a4 -= sgn;\n            del0 -= 4 * ((sgn * b4) >> denshift);\n            if (del0 <= 0) {\n              continue;\n            }\n            sgn = (-b3 >>> 31) | (b3 >> 31);\n            a3 -= sgn;\n            del0 -= 5 * ((sgn * b3) >> denshift);\n            if (del0 <= 0) {\n              continue;\n            }\n            sgn = (-b2 >>> 31) | (b2 >> 31);\n            a2 -= sgn;\n            del0 -= 6 * ((sgn * b2) >> denshift);\n            if (del0 <= 0) {\n              continue;\n            }\n            sgn = (-b1 >>> 31) | (b1 >> 31);\n            a1 -= sgn;\n            del0 -= 7 * ((sgn * b1) >> denshift);\n            if (del0 <= 0) {\n              continue;\n            }\n            a0 -= (-b0 >>> 31) | (b0 >> 31);\n          } else if (sg < 0) {\n            sgn = -((-b7 >>> 31) | (b7 >> 31));\n            a7 -= sgn;\n            del0 -= 1 * ((sgn * b7) >> denshift);\n            if (del0 >= 0) {\n              continue;\n            }\n            sgn = -((-b6 >>> 31) | (b6 >> 31));\n            a6 -= sgn;\n            del0 -= 2 * ((sgn * b6) >> denshift);\n            if (del0 >= 0) {\n              continue;\n            }\n            sgn = -((-b5 >>> 31) | (b5 >> 31));\n            a5 -= sgn;\n            del0 -= 3 * ((sgn * b5) >> denshift);\n            if (del0 >= 0) {\n              continue;\n            }\n            sgn = -((-b4 >>> 31) | (b4 >> 31));\n            a4 -= sgn;\n            del0 -= 4 * ((sgn * b4) >> denshift);\n            if (del0 >= 0) {\n              continue;\n            }\n            sgn = -((-b3 >>> 31) | (b3 >> 31));\n            a3 -= sgn;\n            del0 -= 5 * ((sgn * b3) >> denshift);\n            if (del0 >= 0) {\n              continue;\n            }\n            sgn = -((-b2 >>> 31) | (b2 >> 31));\n            a2 -= sgn;\n            del0 -= 6 * ((sgn * b2) >> denshift);\n            if (del0 >= 0) {\n              continue;\n            }\n            sgn = -((-b1 >>> 31) | (b1 >> 31));\n            a1 -= sgn;\n            del0 -= 7 * ((sgn * b1) >> denshift);\n            if (del0 >= 0) {\n              continue;\n            }\n            a0 += (-b0 >>> 31) | (b0 >> 31);\n          }\n        }\n        coefs[0] = a0;\n        coefs[1] = a1;\n        coefs[2] = a2;\n        coefs[3] = a3;\n        coefs[4] = a4;\n        coefs[5] = a5;\n        coefs[6] = a6;\n        coefs[7] = a7;\n      } else {\n        for (i = _m = lim; _m < num; i = _m += 1) {\n          sum1 = 0;\n          top = out[i - lim];\n          offset = i - 1;\n          for (j = _n = 0; _n < active; j = _n += 1) {\n            sum1 += coefs[j] * (out[offset - j] - top);\n          }\n          del = del0 = pc1[i];\n          sg = (-del >>> 31) | (del >> 31);\n          del += top + ((sum1 + denhalf) >> denshift);\n          out[i] = (del << chanshift) >> chanshift;\n          if (sg > 0) {\n            for (j = _o = _ref = active - 1; _o >= 0; j = _o += -1) {\n              dd = top - out[offset - j];\n              sgn = (-dd >>> 31) | (dd >> 31);\n              coefs[j] -= sgn;\n              del0 -= (active - j) * ((sgn * dd) >> denshift);\n              if (del0 <= 0) {\n                break;\n              }\n            }\n          } else if (sg < 0) {\n            for (j = _p = _ref1 = active - 1; _p >= 0; j = _p += -1) {\n              dd = top - out[offset - j];\n              sgn = (-dd >>> 31) | (dd >> 31);\n              coefs[j] += sgn;\n              del0 -= (active - j) * ((-sgn * dd) >> denshift);\n              if (del0 >= 0) {\n                break;\n              }\n            }\n          }\n        }\n      }\n    };\n\n    return Dplib;\n\n  })();\n\n  module.exports = Dplib;\n\n}).call(this);\n",
    "// Generated by CoffeeScript 1.7.1\n(function() {\n  var Matrixlib;\n\n  Matrixlib = (function() {\n    function Matrixlib() {}\n\n    Matrixlib.unmix16 = function(u, v, out, stride, samples, mixbits, mixres) {\n      var i, l, _i, _j;\n      if (mixres === 0) {\n        for (i = _i = 0; _i < samples; i = _i += 1) {\n          out[i * stride + 0] = u[i];\n          out[i * stride + 1] = v[i];\n        }\n      } else {\n        for (i = _j = 0; _j < samples; i = _j += 1) {\n          l = u[i] + v[i] - ((mixres * v[i]) >> mixbits);\n          out[i * stride + 0] = l;\n          out[i * stride + 1] = l - v[i];\n        }\n      }\n    };\n\n    return Matrixlib;\n\n  })();\n\n  module.exports = Matrixlib;\n\n}).call(this);\n"
  ],
  "sourceRoot": ""
}