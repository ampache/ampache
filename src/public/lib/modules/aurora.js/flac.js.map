{
  "version": 3,
  "file": "generated.js",
  "sources": [
    "/Users/devongovett/projects/codecs/flac.js/node_modules/browserify/node_modules/browser-pack/_prelude.js",
    "/Users/devongovett/projects/codecs/flac.js/index.js",
    "/Users/devongovett/projects/codecs/flac.js/src/decoder.js",
    "/Users/devongovett/projects/codecs/flac.js/src/demuxer.js",
    "/Users/devongovett/projects/codecs/flac.js/src/ogg.js"
  ],
  "names": [],
  "mappings": "AAAA;ACAA;AACA;AACA;AACA;;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtiBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3LA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA",
  "sourcesContent": [
    "(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);throw new Error(\"Cannot find module '\"+o+\"'\")}var f=n[o]={exports:{}};t[o][0].call(f.exports,function(e){var n=t[o][1][e];return s(n?n:e)},f,f.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})",
    "exports.FLACDemuxer = require('./src/demuxer');\nexports.FLACDecoder = require('./src/decoder');\nrequire('./src/ogg');\n",
    "/*\n * FLAC.js - Free Lossless Audio Codec decoder in JavaScript\n * Original C version from FFmpeg (c) 2003 Alex Beregszaszi\n * JavaScript port by Devon Govett and Jens Nockert of Official.fm Labs\n * \n * Licensed under the same terms as the original.  The original\n * license follows.\n *\n * FLAC.js is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * FLAC.js is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n */\n\nvar AV = (window.AV);\n\nvar FLACDecoder = AV.Decoder.extend(function() {\n    AV.Decoder.register('flac', this);\n    \n    this.prototype.setCookie = function(cookie) {\n        this.cookie = cookie;\n        \n        // initialize arrays\n        this.decoded = [];\n        for (var i = 0; i < this.format.channelsPerFrame; i++) {\n            this.decoded[i] = new Int32Array(cookie.maxBlockSize);\n        }\n        \n        // for 24 bit lpc frames, this is used to simulate a 64 bit int\n        this.lpc_total = new Int32Array(2);\n    };\n    \n    const BLOCK_SIZES = new Int16Array([\n               0,      192, 576 << 0, 576 << 1, 576 << 2, 576 << 3,        0,        0,\n        256 << 0, 256 << 1, 256 << 2, 256 << 3, 256 << 4, 256 << 5, 256 << 6, 256 << 7\n    ]);\n    \n    const SAMPLE_RATES = new Int32Array([\n        0, 88200, 176400, 192000,\n        8000, 16000, 22050, 24000, 32000, 44100, 48000, 96000,\n        0, 0, 0, 0\n    ]);\n    \n    const SAMPLE_SIZES = new Int8Array([\n        0, 8, 12, 0, 16, 20, 24, 0\n    ]);\n    \n    const MAX_CHANNELS = 8,\n          CHMODE_INDEPENDENT = 0,\n          CHMODE_LEFT_SIDE = 8,\n          CHMODE_RIGHT_SIDE = 9,\n          CHMODE_MID_SIDE = 10;\n    \n    this.prototype.readChunk = function() {\n        var stream = this.bitstream;\n        if (!stream.available(32))\n            return;\n                            \n        // frame sync code\n        if ((stream.read(15) & 0x7FFF) !== 0x7FFC)\n            throw new Error('Invalid sync code');\n            \n        var isVarSize = stream.read(1),  // variable block size stream code\n            bsCode = stream.read(4),  // block size\n            srCode = stream.read(4),  // sample rate code\n            chMode = stream.read(4),  // channel mode\n            bpsCode = stream.read(3); // bits per sample\n            \n        stream.advance(1); // reserved bit\n        \n        // channels\n        this.chMode = chMode;\n        var channels;\n        \n        if (chMode < MAX_CHANNELS) {\n            channels = chMode + 1;\n            this.chMode = CHMODE_INDEPENDENT;\n        } else if (chMode <= CHMODE_MID_SIDE) {\n            channels = 2;\n        } else {\n            throw new Error('Invalid channel mode');\n        }\n        \n        if (channels !== this.format.channelsPerFrame)\n            throw new Error('Switching channel layout mid-stream not supported.');\n        \n        // bits per sample    \n        if (bpsCode === 3 || bpsCode === 7)\n            throw new Error('Invalid sample size code');\n            \n        this.bps = SAMPLE_SIZES[bpsCode];\n        if (this.bps !== this.format.bitsPerChannel)\n            throw new Error('Switching bits per sample mid-stream not supported.');\n        \n        // sample number or frame number\n        // see http://www.hydrogenaudio.org/forums/index.php?s=ea7085ffe6d57132c36e6105c0d434c9&showtopic=88390&pid=754269&st=0&#entry754269\n        var ones = 0;\n        while (stream.read(1) === 1)\n            ones++;\n        \n        var frame_or_sample_num = stream.read(7 - ones);\n        for (; ones > 1; ones--) {\n            stream.advance(2); // == 2\n            frame_or_sample_num = (frame_or_sample_num << 6) | stream.read(6);\n        }\n                \n        // block size\n        if (bsCode === 0)\n            throw new Error('Reserved blocksize code');\n        else if (bsCode === 6)\n            this.blockSize = stream.read(8) + 1;\n        else if (bsCode === 7)\n            this.blockSize = stream.read(16) + 1;\n        else\n            this.blockSize = BLOCK_SIZES[bsCode];\n            \n        // sample rate\n        var sampleRate;\n        if (srCode < 12)\n            sampleRate = SAMPLE_RATES[srCode];\n        else if (srCode === 12)\n            sampleRate = stream.read(8) * 1000;\n        else if (srCode === 13)\n            sampleRate = stream.read(16);\n        else if (srCode === 14)\n            sampleRate = stream.read(16) * 10;\n        else\n            throw new Error('Invalid sample rate code');\n            \n        stream.advance(8); // skip CRC check\n        \n        // subframes\n        for (var i = 0; i < channels; i++)\n            this.decodeSubframe(i);\n        \n        stream.align();\n        stream.advance(16); // skip CRC frame footer\n        \n        var is32 = this.bps > 16,\n            output = new ArrayBuffer(this.blockSize * channels * (is32 ? 4 : 2)),\n            buf = is32 ? new Int32Array(output) : new Int16Array(output),\n            blockSize = this.blockSize,\n            decoded = this.decoded,\n            j = 0;\n            \n        switch (this.chMode) {\n            case CHMODE_INDEPENDENT:\n                for (var k = 0; k < blockSize; k++) {\n                    for (var i = 0; i < channels; i++) {\n                        buf[j++] = decoded[i][k];\n                    }\n                }\n                break;\n                \n            case CHMODE_LEFT_SIDE:\n                for (var i = 0; i < blockSize; i++) {\n                    var left = decoded[0][i],\n                        right = decoded[1][i];\n\n                    buf[j++] = left;\n                    buf[j++] = (left - right);\n                }\n                break;\n                \n            case CHMODE_RIGHT_SIDE:\n                for (var i = 0; i < blockSize; i++) {\n                    var left = decoded[0][i],\n                        right = decoded[1][i];\n\n                    buf[j++] = (left + right);\n                    buf[j++] = right;\n                }\n                break;\n                \n            case CHMODE_MID_SIDE:\n                for (var i = 0; i < blockSize; i++) {\n                    var left = decoded[0][i],\n                        right = decoded[1][i];\n                    \n                    left -= right >> 1;\n                    buf[j++] = (left + right);\n                    buf[j++] = left;\n                }\n                break;\n        }\n        \n        return buf;\n    };\n    \n    this.prototype.decodeSubframe = function(channel) {\n        var wasted = 0,\n            stream = this.bitstream,\n            blockSize = this.blockSize,\n            decoded = this.decoded;\n        \n        this.curr_bps = this.bps;\n        if (channel === 0) {\n            if (this.chMode === CHMODE_RIGHT_SIDE)\n                this.curr_bps++;\n        } else {\n            if (this.chMode === CHMODE_LEFT_SIDE || this.chMode === CHMODE_MID_SIDE)\n                this.curr_bps++;\n        }\n        \n        if (stream.read(1))\n            throw new Error(\"Invalid subframe padding\");\n        \n        var type = stream.read(6);\n        \n        if (stream.read(1)) {\n            wasted = 1;\n            while (!stream.read(1))\n                wasted++;\n\n            this.curr_bps -= wasted;\n        }\n        \n        if (this.curr_bps > 32)\n            throw new Error(\"decorrelated bit depth > 32 (\" + this.curr_bps + \")\");\n        \n        if (type === 0) {\n            var tmp = stream.read(this.curr_bps, true);\n            for (var i = 0; i < blockSize; i++)\n                decoded[channel][i] = tmp;\n                \n        } else if (type === 1) {\n            var bps = this.curr_bps;\n            for (var i = 0; i < blockSize; i++)\n                decoded[channel][i] = stream.read(bps, true);\n                \n        } else if ((type >= 8) && (type <= 12)) {\n            this.decode_subframe_fixed(channel, type & ~0x8);\n                \n        } else if (type >= 32) {\n            this.decode_subframe_lpc(channel, (type & ~0x20) + 1);\n\n        } else {\n            throw new Error(\"Invalid coding type\");\n        }\n        \n        if (wasted) {\n            for (var i = 0; i < blockSize; i++)\n                decoded[channel][i] <<= wasted;\n        }\n    };\n    \n    this.prototype.decode_subframe_fixed = function(channel, predictor_order) {\n        var decoded = this.decoded[channel],\n            stream = this.bitstream,\n            bps = this.curr_bps;\n    \n        // warm up samples\n        for (var i = 0; i < predictor_order; i++)\n            decoded[i] = stream.read(bps, true);\n    \n        this.decode_residuals(channel, predictor_order);\n        \n        var a = 0, b = 0, c = 0, d = 0;\n        \n        if (predictor_order > 0) \n            a = decoded[predictor_order - 1];\n        \n        if (predictor_order > 1)\n            b = a - decoded[predictor_order - 2];\n        \n        if (predictor_order > 2) \n            c = b - decoded[predictor_order - 2] + decoded[predictor_order - 3];\n        \n        if (predictor_order > 3)\n            d = c - decoded[predictor_order - 2] + 2 * decoded[predictor_order - 3] - decoded[predictor_order - 4];\n            \n        switch (predictor_order) {\n            case 0:\n                break;\n                \n            case 1:\n            case 2:\n            case 3:\n            case 4:\n                var abcd = new Int32Array([a, b, c, d]),\n                    blockSize = this.blockSize;\n                    \n                for (var i = predictor_order; i < blockSize; i++) {\n                    abcd[predictor_order - 1] += decoded[i];\n                    \n                    for (var j = predictor_order - 2; j >= 0; j--) {\n                        abcd[j] += abcd[j + 1];\n                    }\n                    \n                    decoded[i] = abcd[0];\n                }\n                \n                break;\n                \n            default:\n                throw new Error(\"Invalid Predictor Order \" + predictor_order);\n        }\n    };\n    \n    this.prototype.decode_subframe_lpc = function(channel, predictor_order) {\n        var stream = this.bitstream,\n            decoded = this.decoded[channel],\n            bps = this.curr_bps,\n            blockSize = this.blockSize;\n            \n        // warm up samples\n        for (var i = 0; i < predictor_order; i++) {\n            decoded[i] = stream.read(bps, true);\n        }\n\n        var coeff_prec = stream.read(4) + 1;\n        if (coeff_prec === 16)\n            throw new Error(\"Invalid coefficient precision\");\n        \n        var qlevel = stream.read(5, true);\n        if (qlevel < 0)\n            throw new Error(\"Negative qlevel, maybe buggy stream\");\n        \n        var coeffs = new Int32Array(32);\n        for (var i = 0; i < predictor_order; i++) {\n            coeffs[i] = stream.read(coeff_prec, true);\n        }\n        \n        this.decode_residuals(channel, predictor_order);\n        \n        if (this.bps <= 16) {\n            for (var i = predictor_order; i < blockSize - 1; i += 2) {\n                var d = decoded[i - predictor_order],\n                    s0 = 0, s1 = 0, c = 0;\n            \n                for (var j = predictor_order - 1; j > 0; j--) {\n                    c = coeffs[j];\n                    s0 += c * d;\n                    d = decoded[i - j];\n                    s1 += c * d;\n                }\n            \n                c = coeffs[0];\n                s0 += c * d;\n                d = decoded[i] += (s0 >> qlevel);\n                s1 += c * d;\n                decoded[i + 1] += (s1 >> qlevel);\n            }\n            \n            if (i < blockSize) {\n                var sum = 0;\n                for (var j = 0; j < predictor_order; j++)\n                    sum += coeffs[j] * decoded[i - j - 1];\n            \n                decoded[i] += (sum >> qlevel);\n            }\n        } else {\n            // simulate 64 bit integer using an array of two 32 bit ints\n            var total = this.lpc_total;\n            for (var i = predictor_order; i < blockSize; i++) {\n                // reset total to 0\n                total[0] = 0;\n                total[1] = 0;\n\n                for (j = 0; j < predictor_order; j++) {\n                    // simulate `total += coeffs[j] * decoded[i - j - 1]`\n                    multiply_add(total, coeffs[j], decoded[i - j - 1]);                    \n                }\n\n                // simulate `decoded[i] += total >> qlevel`\n                // we know that qlevel < 32 since it is a 5 bit field (see above)\n                decoded[i] += (total[0] >>> qlevel) | (total[1] << (32 - qlevel));\n            }\n        }\n    };\n    \n    const TWO_PWR_32_DBL = Math.pow(2, 32);\n        \n    // performs `total += a * b` on a simulated 64 bit int\n    // total is an Int32Array(2)\n    // a and b are JS numbers (32 bit ints)\n    function multiply_add(total, a, b) {\n        // multiply a * b (we can use normal JS multiplication for this)\n        var r = a * b;\n        var n = r < 0;\n        if (n)\n            r = -r;\n            \n        var r_low = (r % TWO_PWR_32_DBL) | 0;\n        var r_high = (r / TWO_PWR_32_DBL) | 0;\n        if (n) {\n            r_low = ~r_low + 1;\n            r_high = ~r_high;\n        }\n        \n        // add result to total\n        var a48 = total[1] >>> 16;\n        var a32 = total[1] & 0xFFFF;\n        var a16 = total[0] >>> 16;\n        var a00 = total[0] & 0xFFFF;\n\n        var b48 = r_high >>> 16;\n        var b32 = r_high & 0xFFFF;\n        var b16 = r_low >>> 16;\n        var b00 = r_low & 0xFFFF;\n\n        var c48 = 0, c32 = 0, c16 = 0, c00 = 0;\n        c00 += a00 + b00;\n        c16 += c00 >>> 16;\n        c00 &= 0xFFFF;\n        c16 += a16 + b16;\n        c32 += c16 >>> 16;\n        c16 &= 0xFFFF;\n        c32 += a32 + b32;\n        c48 += c32 >>> 16;\n        c32 &= 0xFFFF;\n        c48 += a48 + b48;\n        c48 &= 0xFFFF;\n        \n        // store result back in total\n        total[0] = (c16 << 16) | c00;\n        total[1] = (c48 << 16) | c32;\n    }\n     \n    const INT_MAX = 32767;\n    \n    this.prototype.decode_residuals = function(channel, predictor_order) {\n        var stream = this.bitstream,\n            method_type = stream.read(2);\n            \n        if (method_type > 1)\n            throw new Error('Illegal residual coding method ' + method_type);\n        \n        var rice_order = stream.read(4),\n            samples = (this.blockSize >>> rice_order);\n            \n        if (predictor_order > samples)\n            throw new Error('Invalid predictor order ' + predictor_order + ' > ' + samples);\n        \n        var decoded = this.decoded[channel],\n            sample = predictor_order, \n            i = predictor_order;\n        \n        for (var partition = 0; partition < (1 << rice_order); partition++) {\n            var tmp = stream.read(method_type === 0 ? 4 : 5);\n\n            if (tmp === (method_type === 0 ? 15 : 31)) {\n                tmp = stream.read(5);\n                for (; i < samples; i++)\n                    decoded[sample++] = stream.read(tmp, true);\n                    \n            } else {\n                for (; i < samples; i++)\n                    decoded[sample++] = this.golomb(tmp, INT_MAX, 0);\n            }\n            \n            i = 0;\n        }\n    };\n    \n    const MIN_CACHE_BITS = 25;\n    \n    this.prototype.golomb = function(k, limit, esc_len) {\n        var data = this.bitstream,\n            offset = data.bitPosition,\n            buf = data.peek(32 - offset) << offset,\n            v = 0;\n        \n        var log = 31 - clz(buf | 1); // log2(buf)\n\n        if (log - k >= 32 - MIN_CACHE_BITS && 32 - log < limit) {\n            buf >>>= log - k;\n            buf += (30 - log) << k;\n\n            data.advance(32 + k - log);\n            v = buf;\n            \n        } else {\n            for (var i = 0; data.read(1) === 0; i++)\n                buf = data.peek(32 - offset) << offset;\n\n            if (i < limit - 1) {\n                if (k)\n                    buf = data.read(k);\n                else\n                    buf = 0;\n\n                v = buf + (i << k);\n                \n            } else if (i === limit - 1) {\n                buf = data.read(esc_len);\n                v = buf + 1;\n                \n            } else {\n                v = -1;\n            }\n        }\n        \n        return (v >> 1) ^ -(v & 1);\n    };\n    \n    // Should be in the damned standard library...\n    function clz(input) {\n        var output = 0,\n            curbyte = 0;\n\n        while(true) { // emulate goto in JS using the break statement :D\n            curbyte = input >>> 24;\n            if (curbyte) break;\n            output += 8;\n\n            curbyte = input >>> 16;\n            if (curbyte & 0xff) break;\n            output += 8;\n\n            curbyte = input >>> 8;\n            if (curbyte & 0xff) break;\n            output += 8;\n\n            curbyte = input;\n            if (curbyte & 0xff) break;\n            output += 8;\n\n            return output;\n        }\n\n        if (!(curbyte & 0xf0))\n            output += 4;\n        else\n            curbyte >>>= 4;\n\n        if (curbyte & 0x8)\n            return output;\n            \n        if (curbyte & 0x4)\n            return output + 1;\n            \n        if (curbyte & 0x2)\n            return output + 2;\n            \n        if (curbyte & 0x1)\n            return output + 3;\n\n        // shouldn't get here\n        return output + 4;\n    }\n});\n\nmodule.exports = FLACDecoder;\n",
    "/*\n * FLAC.js - Free Lossless Audio Codec decoder in JavaScript\n * By Devon Govett and Jens Nockert of Official.fm Labs\n *\n * FLAC.js is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * FLAC.js is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n */\n\nvar AV = (window.AV);\n\nvar FLACDemuxer = AV.Demuxer.extend(function() {\n    AV.Demuxer.register(this);\n    \n    this.probe = function(buffer) {\n        return buffer.peekString(0, 4) === 'fLaC';\n    }\n    \n    const STREAMINFO = 0,\n          PADDING = 1,\n          APPLICATION = 2,\n          SEEKTABLE = 3,\n          VORBIS_COMMENT = 4,\n          CUESHEET = 5,\n          PICTURE = 6,\n          INVALID = 127,\n          STREAMINFO_SIZE = 34;\n    \n    this.prototype.readChunk = function() {\n        var stream = this.stream;\n        \n        if (!this.readHeader && stream.available(4)) {\n            if (stream.readString(4) !== 'fLaC')\n                return this.emit('error', 'Invalid FLAC file.');\n                \n            this.readHeader = true;\n        }\n        \n        while (stream.available(1) && !this.last) {                     \n            if (!this.readBlockHeaders) {\n                var tmp = stream.readUInt8();\n                this.last = (tmp & 0x80) === 0x80,\n                this.type = tmp & 0x7F,\n                this.size = stream.readUInt24();\n            }\n            \n            if (!this.foundStreamInfo && this.type !== STREAMINFO)\n                return this.emit('error', 'STREAMINFO must be the first block');\n                \n            if (!stream.available(this.size))\n                return;\n            \n            switch (this.type) {\n                case STREAMINFO:\n                    if (this.foundStreamInfo)\n                        return this.emit('error', 'STREAMINFO can only occur once.');\n                    \n                    if (this.size !== STREAMINFO_SIZE)\n                        return this.emit('error', 'STREAMINFO size is wrong.');\n                    \n                    this.foundStreamInfo = true;\n                    var bitstream = new AV.Bitstream(stream);\n                \n                    var cookie = {\n                        minBlockSize: bitstream.read(16),\n                        maxBlockSize: bitstream.read(16),\n                        minFrameSize: bitstream.read(24),\n                        maxFrameSize: bitstream.read(24)\n                    };\n                \n                    this.format = {\n                        formatID: 'flac',\n                        sampleRate: bitstream.read(20),\n                        channelsPerFrame: bitstream.read(3) + 1,\n                        bitsPerChannel: bitstream.read(5) + 1\n                    };\n                \n                    this.emit('format', this.format);\n                    this.emit('cookie', cookie);\n                \n                    var sampleCount = bitstream.read(36);\n                    this.emit('duration', sampleCount / this.format.sampleRate * 1000 | 0);\n                \n                    stream.advance(16); // skip MD5 hashes\n                    this.readBlockHeaders = false;\n                    break;\n\n                    /*\n                    I am only looking at the least significant 32 bits of sample number and offset data\n                    This is more than sufficient for the longest flac file I have (~50 mins 2-channel 16-bit 44.1k which uses about 7.5% of the UInt32 space for the largest offset)\n                    Can certainly be improved by storing sample numbers and offests as doubles, but would require additional overriding of the searchTimestamp and seek functions (possibly more?)\n                    Also the flac faq suggests it would be possible to find frame lengths and thus create seek points on the fly via decoding but I assume this would be slow\n                    I may look into these thigns though as my project progresses\n                    */\n                    case SEEKTABLE:\n                        for(var s=0; s<this.size/18; s++)\n                        {\n                            if(stream.peekUInt32(0) == 0xFFFFFFFF && stream.peekUInt32(1) == 0xFFFFFFFF)\n                            {\n                                //placeholder, ignore\n                                stream.advance(18);\n                            } else {\n                                if(stream.readUInt32() > 0)\n                                {\n                                    this.emit('error', 'Seek points with sample number >UInt32 not supported');\n                                }\n                                var samplenum = stream.readUInt32();\n                                if(stream.readUInt32() > 0)\n                                {\n                                    this.emit('error', 'Seek points with stream offset >UInt32 not supported');\n                                }\n                                var offset = stream.readUInt32();\n\n                                stream.advance(2);\n\n                                this.addSeekPoint(offset, samplenum);\n                            }\n                        }\n                        break;\n\n                case VORBIS_COMMENT:\n                    // see http://www.xiph.org/vorbis/doc/v-comment.html\n                    this.metadata || (this.metadata = {});\n                    var len = stream.readUInt32(true);\n                    \n                    this.metadata.vendor = stream.readString(len);\n                    var length = stream.readUInt32(true);\n                    \n                    for (var i = 0; i < length; i++) {\n                        len = stream.readUInt32(true);\n                        var str = stream.readString(len, 'utf8'),\n                            idx = str.indexOf('=');\n                            \n                        this.metadata[str.slice(0, idx).toLowerCase()] = str.slice(idx + 1);\n                    }\n                    \n                    // TODO: standardize field names across formats\n                    break;\n                    \n                case PICTURE:\n                    var type = stream.readUInt32();\n                    if (type !== 3) { // make sure this is album art (type 3)\n                        stream.advance(this.size - 4);\n                    } else {\n                        var mimeLen = stream.readUInt32(),\n                            mime = stream.readString(mimeLen),\n                            descLen = stream.readUInt32(),\n                            description = stream.readString(descLen),\n                            width = stream.readUInt32(),\n                            height = stream.readUInt32(),\n                            depth = stream.readUInt32(),\n                            colors = stream.readUInt32(),\n                            length = stream.readUInt32(),\n                            picture = stream.readBuffer(length);\n                    \n                        this.metadata || (this.metadata = {});\n                        this.metadata.coverArt = picture;\n                    }\n                    \n                    // does anyone want the rest of the info?\n                    break;\n                \n                default:\n                    stream.advance(this.size);\n                    this.readBlockHeaders = false;\n            }\n            \n            if (this.last && this.metadata)\n                this.emit('metadata', this.metadata);\n        }\n        \n        while (stream.available(1) && this.last) {\n            var buffer = stream.readSingleBuffer(stream.remainingBytes());\n            this.emit('data', buffer);\n        }\n    }\n    \n});\n\nmodule.exports = FLACDemuxer;\n",
    "var AV = (window.AV);\n\n// if ogg.js exists, register a plugin\ntry {\n  var OggDemuxer = (window.AV.OggDemuxer);\n} catch (e) {};\nif (!OggDemuxer) return;\n\nOggDemuxer.plugins.push({\n  magic: \"\\177FLAC\",\n  \n  init: function() {\n    this.list = new AV.BufferList();\n    this.stream = new AV.Stream(this.list);\n  },\n  \n  readHeaders: function(packet) {\n    var stream = this.stream;\n    this.list.append(new AV.Buffer(packet));\n    \n    stream.advance(5); // magic\n    if (stream.readUInt8() != 1)\n      throw new Error('Unsupported FLAC version');\n      \n    stream.advance(3);\n    if (stream.peekString(0, 4) != 'fLaC')\n      throw new Error('Not flac');\n      \n    this.flac = AV.Demuxer.find(stream.peekSingleBuffer(0, stream.remainingBytes()));\n    if (!this.flac)\n      throw new Error('Flac demuxer not found');\n    \n    this.flac.prototype.readChunk.call(this);\n    return true;\n  },\n  \n  readPacket: function(packet) {\n    this.list.append(new AV.Buffer(packet));\n    this.flac.prototype.readChunk.call(this);\n  }\n});\n"
  ],
  "sourceRoot": ""
}